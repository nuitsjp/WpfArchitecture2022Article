# 論理ビュー

論理ビューでは、WPFアプリケーションの論理的な構成と、そこに登場する要素を設計します。

設計にあたり、ユースケースビュー・非機能要件ビューで整理した下記の要件をインプットにします。

1. ユースケースビュー
   1. 基本パターン
      1. 再発注する
1. 非機能要件ビュー
   1. 運用・保守性
      1. 通常運用
         1. 運用監視
            1. 監視情報
      1. その他運用管理方針
         1. 機能追加・変更容易性
            1. 影響範囲の限定
   1. セキュリティ
      1. アクセス・利用制限
         1. 認証機能
            1. 管理権限を持つ主体の認証
            1. 管理権限を持たない主体の認証

論理ビューは以下の要素で構成します。

- 論理ノード
- 論理レイヤー

論理ノードでは、システムおよび開発に登場する論理的なノードと、その依存関係を決定します。たとえばクライアント・サーバー構成ならノードはクライアントとデータベースの構成になるでしょうし、間にWeb APIを挟んだ三層アーキテクチャであれば、Web APIノードが登場するでしょう。

論理レイヤーでは、ソフトウェアのレイヤー構成を決定します。どのようなレイヤーがあり、そのレイヤー内にどのようなオブジェクトが登場するか決定します。アプリケーションアーキテクチャの花形といっても過言ではないでしょう。

## 論理ノード

論理ノード構成については、見積時から大きな変更はありません。詳細は「[見積時の論理構成の決定](https://codezine.jp/article/detail/16953?p=4&anchor=0)」を参照してください。

![](/Article02/スライド11.PNG)

1点。認証ノードを削除しています。WPFアプリケーションの認証については、Windows統合認証か、Active Directoryを用いた認証のいずれかを利用するケースが多いかと思います。

Windows統合認証を利用する場合、認証ノードはWeb APIノードに統合してしまうのがシンプルです。Active Directoryで認証する場合は、それらのノードが発生します。今回はそこの実装は限定せず、簡便な実装で代替するため、言及を避けることとしました。


## 論理レイヤー

本稿ではドメイン駆動設計およびクリーンアーキテクチャ、そしてMVVMパターンを中心に論理構成を設計します。

ドメイン駆動設計とクリーンアーキテクチャは非常に相性が良い設計手法です。

ドメイン駆動設計で大切なのはもちろんドメインになります。このとき、たとえば通常の垂直レイヤーアーキテクチャを用いて設計した場合、ドメインがインフラへのアクセス相に依存する形となってしまいます。

![](/Article02/レイヤーモデル.PNG)

基本的に依存関係は、重要度の低い方から、高い方に向いていることが好ましいです。これは重要度が低い箇所の変更影響を、重要度の高い箇所が受けないようにするためです。

ドメイン駆動設計においてドメインはもっとも大切な構成要素なので、リポジトリーの実装の影響をうけるようなことは避けるべきです。リポジトリーの実装がドメインに依存するように設計するべきです。これを実現するために手段としてクリーンアーキテクチャが利用できます。

下図は有名なクリーンアーキテクチャの図です。

![](/Article02/CleanArchitecture.jpg)

この垂直ではなくサークル状のレイヤーアーキテクチャを採用します。サークル状のレイヤーで大切なことは、依存関係は外側から内側への一方通行になっていて、逆は存在しないということです。

中央のEntityをドメインと読み替えると、ほぼそのまま適用できるようになります。クリーンアーキテクチャの詳細はここでは記載しきれませんので、繰り返しになりますが筆者のブログである「[世界一わかりやすいClean Architecture](https://www.nuits.jp/entry/easiest-clean-architecture-2019-09)」をご覧ください。

またドメイン駆動設計におけるドメインとユースケース（またはアプリケーション）の実装にCQRSパターンを利用します。CQRSパターンとは「コマンド・クエリ責務分離（Command and Query Responsibility Segregation）」を実現するパターンです。

ドメイン駆動設計では、通常はビジネス上のオブジェクトをエンティティを用いて表現します。これは正規化された構造をもつオブジェクトで、ビジネスロジックを実装します。ビジネスロジックの実行はエンティティを呼び出して行います。

しかしユースケースを実現するためには、おもに性能やリソース利用量などの非機能要件から、つねにエンティティを用いるわけにいかない場合があります。もっとも一般的なのは複雑な検索条件を持つ検索機能の実装などです。これらの機能は一般的にRDB上に実現する場合、複数のテーブルを結合して検索を行います。この実装をドメイン駆動のエンティティのみで実現しようとした場合、大量のオブジェクトをメモリー上に展開して処理する必要があり、十分な速度がでない上に、大量のメモリーを消費してしまうことになります。そこで利用するのがCQRSパターンです。

CQRSパターンは、ドメイン駆動設計固有の概念ではありません。書き込みに使うオブジェクトと、参照に使うオブジェクトを分けて設計しようというパターンです。これは書き込みに適した構造化されたデータだと、参照時に性能が出ないといったケースにおいて、それぞれを分けて考えましょうというパターンです。

つまりエンティティをコマンド（C）モデルで実現する。ユースケースを実現する上で、エンティティでは支障がある場合に、ユースケースを実現するオブジェクトとして参照用のクエリー（Q）モデルを利用する。これによりドメイン駆動の利点を損なわず、非機能を実現できるようになります。

詳細は以下のMicrosoftのサイトをご覧ください。

- [CQRSパターン](https://learn.microsoft.com/ja-jp/azure/architecture/patterns/cqrs)

さて、これらを考慮した結果、論理レイヤーの構成としては、今回のケースではつぎのようしました。

![](/Article02/スライド13.PNG)

外側は内側に対して依存し、その際に直接接している内側だけでなく、さらにその内側へ直接依存することを許容します。

レイヤーアーキテクチャでは厳密なレイヤーアーキテクチャと、柔軟なレイヤーアーキテクチャがあります。厳密な場合は、直下への依存しか許可しませんが、柔軟な場合は相対的にしたのレイヤーであれば、いずれの利用も許可します。

今回の論理サークルは柔軟な関係として扱います。その必要があるのですが、詳細は後ほど別途説明します。

さて、ドメインは全社共通で利用する「企業ドメイン」と、業務別の「業務ドメイン」の2つに分けました。業務ドメインは企業ドメインを利用できますが、その逆はないということを明確にすることが目的です。

ドメインの外側はユースケースになります。ドメイン駆動設計ではユースケースをアプリケーションという事もありますが、本稿にはユースケースビューがあるようにユースケース駆動で考えているため、ドメインの外側はユースケースとしました。ユースケース層にはユースケースごとに、ユースケース内でつかうオブジェクトを実装します。

ユースケースの外側は、プレゼンテーション・コントローラー・ゲートウェイになります。

プレゼンテーションはWPFで実装し、MVVMパターンを採用します。そのためプレゼンテーションとはViewとViewModelの双方を指します。

コントローラーはWeb APIの実装です。Web APIはgRPCで実装します。ASP.NETではWeb APIを実装はControllerとなるため、コントローラーという名称を利用しています。

ゲートウェイはデータベース操作の実装です。エンティティを永続化を扱うリポジトリーの実装と、ユースケースのクエリーモデルのデータベース操作を扱う実装が存在します。

全体の処理の流れとしてはつぎのようになります。

![](/Article02/スライド14.PNG)

ちょっと分かりにくいので、もういったん簡略化しましょう。

企業ドメインと業務ドメインをいったん統合してドメインに。ユースケースをいったん取り除きます。

![](/Article02/スライド15.PNG)

そのうえで、つぎのシナリオを実現するオブジェクトを抽出してきます。

- 任意のProductをUIに表示する。

これを実現するために必要最低限のオブジェクトをサークル上にプロットしたものが下記の図です。

![](/Article02/スライド17.PNG)

破線が依存、つまり呼出しの向きで、実践はインターフェイスの実装を表します。

これらのオブジェクトは、クライアントとサーバー上につぎのように振り分けられます。

![](/Article02/スライド16.PNG)


インターフェイスであるIProductRepositoryとIProductRepositoryClient（とProduct）は、実際にはサーバーサイドにも配置されますが、同一性と依存性を分かりやすくするためにクライアント側のみにプロットしています。

プロットしたオブジェクトは下記のとおりです。

|要素|説明|
|--|--|
|View|MVVMパターンのView|
|ViewModel|MVVMパターンのViewModel|
|Product|製品を表すエンティティ|
|IProductRepository|Productを取得するためのリポジトリー|
|ProductRepository|IProductRepositoryの実装。DB操作を実装する。|
|ProductRepositoryClient|IProductRepositoryの実装。IProductRepositoryServiceを利用してgRPCのクライアントを生成し、サーバー上のProductRepositoryServerを呼び出すことで、IProductRepositoryの実装を実現する。|
|IProductRepositoryService|IProductRepositoryをgRPC越しに実装する際の、Web APIのインターフェイス。|
|ProductRepositoryServer|IProductRepositoryServiceの実装。サーバー上で動作し、ProductRepositoryを呼び出すことでIProductRepositoryの実装を実現する。|

手続きをシーケンス図で表すとつぎのようになります。

![](/Article02/スライド18.PNG)

ユーザーがUIを操作すると、ViewからViewModelが呼ばれ、ViewModelはIProductRepositoryを利用してProductを取得します。

ただ実際にDBを操作するIProductRepositoryの実態はサーバー上で動作しているため、クライアント上で直接利用できません。このため、サーバー上のProductRepositoryを呼び出すため、ViewModelからは実際にはProductRepositoryClientを呼び出します。

ProductRepositoryClientはIProductRepositoryServiceからgRPCのクライアントを生成し、サーバー上のProductRepositoryServerを呼び出します。

ProductRepositoryServerはIProductRepository経由でProductRepositoryを利用してProductを取得して返却します。

大まかな流れはこの通りです。

初期開発だけ考えた場合、IProductRepositoryインターフェイスがgRPCに依存することを許容することで下記が不要になり生産性が向上します。

- ProductRepositoryClient
- IProductRepositoryService
- ProductRepositoryServer

ただそうした場合、ドメインがgRPCの実装に依存してしまいます。クリーンアーキテクチャの鉄則「フレームワーク非依存」が守れなくなります。ドメインの実装が、通信プロトコルに依存することは、メンテナンス性の低下につながります。これらの実装が大量に発生し、実装が負担になるのであれば、コード生成で上記を生成しても良いでしょう。

なお今回はサンプルコードでは、コード生成は行っていません。コード生成を含めると、生成されるコードが隠ぺいされてしまったり、コード生成自体の理解が必要になるため、WPFアプリケーションのアーキテクチャが主題である本稿では割愛しました。

さてここで、省略した図の処理の流れと、全レイヤーを描画した図上での処理の流れを比較してみると・・・

![](/Article02/スライド19.PNG)

完全に一致しましたね。

