# 初期論理ビューの設計

## ドメイン駆動とクリーンアーキテクチャ

さてアプリケーション全体の構成を考えたとき、ドメイン駆動設計単独では、どのように論理レイヤーを構成し、どの役割のオブジェクトをどのレイヤーに配置するのか規定されていません。そこで活用したいのがクリーンアーキテクチャです。ドメイン駆動設計とクリーンアーキテクチャは非常に相性が良い設計手法です。

クリーンアーキテクチャではなく、通常の垂直型のレイヤーアーキテクチャを用いた場合、概ね次のようなレイヤー構成になります。

![](/Article02/レイヤーモデル.png)

ドメインがインフラへのアクセス層に依存する形となっています。

基本的に依存関係は、重要度の低い方から、高い方に向いていることが好ましいです。これは重要度が低い箇所の変更影響を、重要度の高い箇所が受けないようにするためです。このあたりの課題は[筆者のクリーンアーキテクチャの解説](https://www.nuits.jp/entry/easiest-clean-architecture-2019-09)を一読いただければ、ご理解いただけます。

ドメイン駆動設計でもっとも重要なのはドメインになります。垂直レイヤーアーキテクチャを用いると、ドメインとリポジトリー実装の依存関係が、理想とは逆の方向になっているのが見て取れます。

さて下図は有名なクリーンアーキテクチャの図です。

![](/Article02/CleanArchitecture.jpg)

クリーンアーキテクチャを採用してEntityをドメインに置き換えて見てください。

サークルの左から右に向かっている矢印が依存の方向です。ドメインがもっとも内側にあって、ドメインはいずれにも依存しておらず、垂直型より良い設計になっているのがわかります。

さてクリーンアーキテクチャの詳細は先の記事を見ていただくとして、クリーンアーキテクチャについて誤解されがちな、いくつかの点についてここでも補足しておきたいと思います。

クリーンアーキテクチャでもっとも大切なことは、アーキテクチャ上もっとも重要な要素を中央のレイヤーに配置して、依存関係はすべて外から内に向けるという点にあります。

ただしそうすると、ドメインからリポジトリーの呼び出しのような、処理の流れが内側から外側にながれる部分の実現が困難になります。そのため、右下の実装例のように制御の逆転を使います。処理の流れとしては内側から外側にながれますが、依存性は一貫して外から内側へ向かうようにしましょう、というのが上記の図になります。レイヤー数や登場要素を、上記の図の通りにしましょうというアーキテクチャではありません。

## ドメインレイヤーの分割

さてここで、あらためて境界付けられたコンテキストを見なおしてみましょう。

![](/Article02/スライド10.PNG)

購買ドメインの上位にAdventureWorksドメインが存在します。AdventureWorksドメインは、認証・製造・販売ドメインからも利用される汎用的なドメインです。そのためEntityの部分を単純にドメインに置き換えるのではなく、AdventureWorksドメインと購買ドメインの2層に分けたほうが良さそうです。

またもっとも外側のFrameworks & Driversレイヤーの要素は、実際に今回のドメインで必要となるものを記載しましょう。

それらを反映した現在のレイヤーモデルはつぎのとおりです。

![](/Article02/スライド13.PNG)

## レイヤーアーキテクチャにおける選択

さてレイヤーアーキテクチャには2つの選択肢があります。

1. 厳密なレイヤーアーキテクチャ
2. 柔軟なレイヤーアーキテクチャ

厳密なアーキテクチャを選択した場合は、直下への依存しか許可しません。柔軟なレイヤーアーキテクチャを選択した場合は、相対的に下位のレイヤーであれば依存（利用）を許可します。厳密なレイヤーアーキテクチャを採用した場合、レイヤーをまたいだ内側を利用したい場合、ひとつ外側がそれをラップして隠ぺいする必要があります。たとえば今回であれば、プレゼンテーションがドメインを利用する場合、つねにユースケースでラップして隠ぺいすることになります。

厳密なレイヤーアーキテクチャの方が、内側の影響を受けにくくなるため保守性が向上し、柔軟なレイヤーアーキテクチャは内側を隠ぺいするコードが必要ないため、生産性が高くなります。

結論から言うと、今回は柔軟なレイヤーアーキテクチャを選択します。大きな理由が2つあります。

1. AdventureWorksドメインをラップしてしまうと、生産性や品質に対する影響が大きい
2. リポジトリーの実装などを考慮すると厳密なレイヤーアーキテクチャでは実現できない

### AdventureWorksドメインをラップしてしまうと、生産性や品質に対する影響が大きい

前述しましたが、AdventureWorksドメインにはつぎのようなオブジェクトを定義します。

|オブジェクト|説明|
|--|--|
|Date|時刻を持たない年月日|
|Days|日数|
|Dollar|通貨（日本企業の場合はYenなど）|
|Gram|重量グラム|
|DollarPerGram|グラム当たりの料金|

AdventureWorksドメインにおけるプリミティブな型をValue Objectとして実装するため、これらを一々ユースケースでラップすると生産性が低下しますし、ラップミスの発生もあり得るため、品質も低下します。

そもそも厳密にした場合、AdventureWorksコンテキストを共有カーネルにした意味が無くなってしまいます。

### リポジトリーの実装などを考慮すると厳密なレイヤーアーキテクチャでは実現できない

たとえば購買ドメインには購買先を表すVendorエンティティと、そのリポジトリーであるIVendorRepositoryインターフェイスを定義することになるでしょう。そして、VendorRepositoryクラスはゲートウェイに実装されます。

![](/Article02/スライド23.PNG)

VendorRepositoryクラスからIVendorRepositoryインターフェイスへの依存は、ユースケース層を跨いでいますが、さすがにここをユースケース層でラップするのは助長にすぎます。

というわけで今回は柔軟なレイヤーアーキテクチャを選択します。

## Frameworks & Driversレイヤー

もっとも外側のFrameworks & Driversレイヤーは、アプリケーションから利用するフレームワークやミドルウェアのレイヤーで、購買ドメイン外のレイヤーです。

ユーザーインターフェイスはWPF上に構築し、永続仮想としてはSQL Serverを利用します。またクライアントとデータベースの間にWeb APIを挟んだ三層アーキテクチャとしたいため、Web APIをMagicOnionで実現します。

クリーンアーキテクチャ本にも記載されていますが、抽象化とは具体化を遅延させるための手段でもあります。そのためこの時点で具体的なFrameworkやDriverを決定する必要はありません。

ただ現実的な話、開発がスタートしてアーキテクチャを設計する段階では、Frameworks & Driversレイヤーの実体は決定しているものが多いです。なぜなら見積に影響するため、見積時のアーキテクチャ設計で多くの場合、十分に検討した上で決定しているからです。

すでに実体が決定しているなら遠慮せずWPFやSQL Server、MagicOnionのように具体的な要素をプロットしましょう。そのことはアーキテクチャ設計を容易にする面もあるからです。

一番分かりやすいのはWPFでしょうか。WPFで実装する場合、とくに理由がなければMVVMパターンを採用するでしょう。MVVMパターンを前提に設計されたUIフレームワークだからです。

このように外側の詳細の決定によって、内側の設計が容易になることがあります。そのため最外周が決定した段階で具体的な名称を記載しておくと良いと思います。

繰り返しますが。これは抽象化を利用して具象の決定を遅らせることを否定するものではありません。
## 初期オブジェクトのプロット

さて、前述のレイヤーモデルではさすがにオブジェクトが少なくて、初期の実装ビュー（つまりコンポーネント分割）することも難しいです。これ以上は代表的なユースケースを設計してみないと設計できないかというと、そうでもありません。

1. ドメイン駆動設計
2. クリーンアーキテクチャ
3. Web APIを挟んだ三層モデル
4. UIはWPF
5. Web APIはMagicOnion

ここまでは決まっています。となると、ユースケースに関係なく、ある程度はクラスを導出できそうです。

おそらくユーザーが何らかの操作をした場合、つぎのような振る舞いになるはずです。

1. ユーザーがViewを操作する
2. ViewはViewModelを呼ぶ
3. ViewModelはリポジトリーを呼び出してエンティティの取得を試みる
4. クライアントからgRPCを利用してサーバーサイドを呼び出す
5. サーバーサイドはリポジトリーの実装を呼び出してエンティティを取得する

これが正しいとして代表的なオブジェクトをレイヤーモデル内にプロットしてみたのがこちらです。

![](/Article02/スライド38.PNG)

青の破線は呼出し経路です。おおむね、先の手順の通りとなっているのが見て取れます。

ポイントが何点かあります。

データベース操作はWeb APIノード上で実施されて、クライアントからは行われません。そのためViewModelからIVendorRepositoryを呼び出した場合、実際に呼び出されるのはVendorRepositoryではなくて、VendorRepositoryClientです。

VendorRepositoryClientは、内部でIVendorRepositoryServiceを呼び出します。IVendorRepositoryServiceはMagicOnionでgRPCを実装するためのインターフェイスです。VendorRepositoryClientが呼び出すIVendorRepositoryServiceの実体はVendorRepositoryServiceではなくて、MagicOnionによって動的に生成されたオブジェクトになります。ちょっと分かりにくいので、VendorRepositoryClientの抜粋コードを見てみましょう。

```cs
public class VendorRepositoryClient : IVendorRepository
{
    private readonly MagicOnionConfig _config;

    public VendorRepositoryClient(MagicOnionConfig config)
    {
        _config = config;
    }

    public async Task<Vendor> GetVendorByIdAsync(VendorId vendorId)
    {
        var server = MagicOnionClient.Create<IVendorRepositoryService>(GrpcChannel.ForAddress(_config.Address));
        return await server.GetVendorByIdAsync(vendorId);
    }
}
```

GetVendorByIdAsyncメソッドを呼び出すと、コンストラクターでインジェクションされたMagicOnionConfigからIVendorRepositoryServiceを作成し、GetVendorByIdAsyncメソッドを呼び出すことで、ネットワーク経由でサーバーサイドを呼び出します。

IVendorRepositoryServiceとIVendorRepositoryをまとめて1つにしたくなりますが、IVendorRepositoryService側のインターフェイスがMagicOnionにガッツリ依存するため、それはできません。実際のコードを見比べてみましょう。

```cs
public interface IVendorRepository
{
    Task<Vendor> GetVendorByIdAsync(VendorId vendorId);
}

public interface IVendorRepositoryService : IService<IVendorRepositoryService>
{
    UnaryResult<Vendor> GetVendorByIdAsync(VendorId vendorId);
}
```

戻り値がTask<Vendor>とUnaryResult<Vendor>で異なります。UnaryResultはMagicOnionで定義されている構造体なので、これを統合してしまうと、ドメイン層がMagicOnionに依存する形となってしまいうため統合できません。

なお、この時点で完全に正しい必要はありません。おおよそ正しそうな状態にもっていって、あとは後続の設計の中で精度を高めていきます。完全に正しいモデルでなくても、このレベルのモデルがあると後続の検討が容易になります。

さて、これ以上は実際のユースケースを設計しながら進めたほうが良いでしょう。ということで、初期の論理ビューとしては、いったんこの辺りとしておきます。

