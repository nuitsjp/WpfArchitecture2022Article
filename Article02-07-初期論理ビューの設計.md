# 初期論理ビューの設計

## ドメイン駆動とクリーンアーキテクチャ

さてアプリケーション全体の構成を考えたとき、ドメイン駆動設計単独では、どのように論理レイヤーを構成し、どの役割のオブジェクトをどのレイヤーに配置するのか規定されていません。そこで活用したいのがクリーンアーキテクチャです。

ドメイン駆動設計とクリーンアーキテクチャは非常に相性が良い設計手法です。

ドメイン駆動設計で大切なのはもちろんドメインになります。このとき、たとえば通常の垂直レイヤーアーキテクチャを用いて設計した場合、上から下への一方通行の依存関係になります。

![](/Article02/レイヤーモデル.PNG)

つまり、ドメインがインフラへのアクセス層に依存する形となってしまいます。

基本的に依存関係は、重要度の低い方から、高い方に向いていることが好ましいです。これは重要度が低い箇所の変更影響を、重要度の高い箇所が受けないようにするためです。このあたりの課題は[筆者のクリーンアーキテクチャの解説](https://www.nuits.jp/entry/easiest-clean-architecture-2019-09)を一読いただければ、ご理解いただけます。

詳細は先の記事を見ていただくとして、クリーンアーキテクチャについて誤解されがちないくつかの点について先に説明しておきたいと思います。下図は有名なクリーンアーキテクチャの図です。

![](/Article02/CleanArchitecture.jpg)

クリーンアーキテクチャでもっとも大切なことは、アーキテクチャ上もっとも重要な要素を中央のレイヤーに配置して、依存関係はすべて外から中に向けるという点にあります。ただしそうすると、ドメインからリポジトリーの呼出しのような部分の実現が困難になります。そのため、右下の実装例のように制御の逆転を使うことで、依存性が中から外に向かわないようにしましょうというのが上記の図になります。レイヤー数や登場要素を、上記の図の通りにしましょうというアーキテクチャではありません。

さてドメイン駆動設計において、もっとも大切な構成要素はもちろんドメインです。そのためリポジトリーの実装の影響をうけるようなことは避けるべきです。リポジトリーの実装がドメインに依存するように設計するべきです。これを実現するために手段としてクリーンアーキテクチャが利用できます。中央のEntityをドメインと読み替えると、ほぼそのまま適用できるようになります。

ここであらためて、境界付けられたコンテキストを見なおしてみましょう。

![](/Article02/スライド10.PNG)

購買ドメインの上位にAdventureWorksドメインが存在します。AdventureWorksドメインは、認証・製造・販売ドメインからも利用される汎用的なドメインです。そのためEntityの部分を単純にドメインに置き換えるのではなく、AdventureWorksドメインと購買ドメインの2層に分けたほうが良さそうです。

またもっとも外側のFrameworks & Driversレイヤーの要素は、実際に今回のドメインで必要となるものを記載しましょう。

それらを反映した現在のレイヤーモデルはつぎのとおりです。

![](/Article02/スライド13.PNG)

## レイヤーアーキテクチャにおける選択

さてレイヤーアーキテクチャには2つの選択肢があります。

1. 厳密なレイヤーアーキテクチャ
2. 柔軟なレイヤーアーキテクチャ

厳密なアーキテクチャを選択した場合は、直下への依存しか許可しません。柔軟なレイヤーアーキテクチャを選択した場合は、相対的に下位のレイヤーであれば依存（利用）を許可します。厳密なレイヤーアーキテクチャを採用した場合、レイヤーをまたいだ内側を利用したい場合、ひとつ外側がそれをラップして隠ぺいする必要があります。たとえば今回であれば、プレゼンテーションがドメインを利用する場合、つねにユースケースでラップして隠ぺいすることになります。

厳密なレイヤーアーキテクチャの方が、内側の影響を受けにくくなるため保守性が向上し、柔軟なレイヤーアーキテクチャは内側を隠ぺいするコードが必要ないため、生産性が高くなります。

結論から言うと、今回は柔軟なレイヤーアーキテクチャを選択します。大きな理由が2つあります。

1. AdventureWorksドメインをラップしてしまうと、生産性や品質に対する影響が大きい
2. リポジトリーの実装などを考慮すると厳密なレイヤーアーキテクチャでは実現できない

### AdventureWorksドメインをラップしてしまうと、生産性や品質に対する影響が大きい

前述しましたが、AdventureWorksドメインにはつぎのようなオブジェクトを定義します。

|オブジェクト|説明|
|--|--|
|Date|時刻を持たない年月日|
|Days|日数|
|Dollar|通貨（日本企業の場合はYenなど）|
|Gram|重量グラム|
|DollarPerGram|グラム当たりの料金|

AdventureWorksドメインにおけるプリミティブな型をValue Objectとして実装するため、これらを一々ユースケースでラップすると生産性が低下しますし、ラップミスの発生もあり得るため、品質も低下します。

そもそも厳密にした場合、AdventureWorksコンテキストを共有カーネルにした意味が無くなってしまいます。

### リポジトリーの実装などを考慮すると厳密なレイヤーアーキテクチャでは実現できない

たとえば購買ドメインには購買先を表すVendorエンティティと、そのリポジトリーであるIVendorRepositoryインターフェイスを定義することになるでしょう。そして、VendorRepositoryクラスはゲートウェイに実装されます。

![](/Article02/スライド23.PNG)

VendorRepositoryクラスからIVendorRepositoryインターフェイスへの依存は、ユースケース層を跨いでいますが、さすがにここをユースケース層でラップするのは助長にすぎます。

というわけで今回は柔軟なレイヤーアーキテクチャを選択します。

## Frameworks & Driversレイヤー

さて外側が具象的で、内側がより抽象的な構造になっています。最も外側のFrameworks & Driversレイヤーは、アプリケーションから利用するフレームワークやミドルウェアのレイヤーで、開発対象外のレイヤーです。

ユーザーインターフェイスはWPF上に構築し、永続仮想としてはSQL Serverを利用します。またクライアントとデータベースの間にWeb APIを挟んだ三層アーキテクチャとしたいため、Web APIをMagicOnionで実現します。

クリーンアーキテクチャ本にも記載されていますが、抽象化とは具体化を遅延させるための手段でもあります。そのためこの時点で具体的なFrameworkやDriverを決定する必要はありません。

ただ現実的な話、開発がスタートしてアーキテクチャを設計する段階では、Frameworks & Driversレイヤーの実体は決定しているものが多いです。なぜなら見積に影響するため、見積時のアーキテクチャ設計で多くの場合、十分に検討した上で決定しているからです。

すでに実体が決定しているなら遠慮せずWPFやSQL Server、MagicOnionのように具体的な要素をプロットしましょう。そのことはアーキテクチャ設計を容易にする面もあるからです。

一番分かりやすいのはWPFでしょうか。WPFで実装する場合、とくに理由がなければMVVMパターンを採用するでしょう。MVVMパターンを前提に設計されたUIフレームワークだからです。

このように外側の詳細の決定によって、内側の設計が用意になることがあります。そのため最外周が決定した段階で具体的な名称を記載しておくと良いと思います。

これもちろん、抽象化を利用して具象の決定を遅らせることを否定するものではありません。

さて、これ以上は実際のユースケースを設計しながら進めたほうが良いでしょう。ということで、初期の論理ビューとしては、いったんこの辺りとしておきます。

