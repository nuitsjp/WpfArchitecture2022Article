# 初期の配置ビュー

さて予算編での論理的な配置図はつぎの通りでした。

![](/Article02/スライド21.PNG)

開発環境のパッケージと、実行環境の購買・認証・販売・製造パッケージがあり、それぞれに論理的なノードと、ノード上に配置されるコンポーネントを記載しています。詳細は[予算編を参照](https://codezine.jp/article/detail/16953?p=4&anchor=0)してください。

予算決定時には十分なモデルですが、開発時にはたとえば費用の発生しないOSS選定などが行われておらず不十分です。ユースケースの実装ビューを設計しながらそれらを導出します。ただこの時点で検討しておいても良さそうなものもあります。とくにノード間の関係に起因する要素は、配置ビュー上で考えると分かりやすいです。

具体的にはクライアントとWeb API間のメッセージングに何を利用するか、ここで仮決めしておいた方が良さそうです。

Web API実装の選択肢として、つぎのものを候補として検討します。

1. REST
2. gRPC
3. GraphQL

結論としては今回はgRPCを利用する想定で設計を進めます。理由はいくつかあります。

1. 購買ドメインでは、外部システムへ「発注する」ようなRPC（Remote Procedure Call）のようなスタイルのメッセージがあり、RESTのようなリソース要求スタイルか、RPCスタイルかのどちらか一方に寄せることで設計を簡略化するとした場合、gRPCに寄せたほうが素直な設計に感じる
1. 購買ドメインのWeb APIを直接外部に公開する想定はなく、RESTほどの相互接続性は必要ない
1. 同様にGraphQLほどの柔軟性も必要ない
1. RESTとgRPCでは単純にgRPCの方が軽くて速いことが多い
1. .NETにおけるgRPCでは[MagicOnionというOSS](https://github.com/Cysharp/MagicOnion)を利用することで、C#のインターフェイスベースでの設計・実装が可能で、RPCスタイルのデメリット（エンドポイントが分かりにくい）を解消できる

gRPCの実装にはMagicOnionを利用する想定ということで、モデルに追加しておきましょう。

![](/Article02/スライド21.PNG)

# 初期の論理ビュー

## 初期論理レイヤーの作成

さて本稿では、ドメイン駆動設計およびクリーンアーキテクチャをベースにアーキテクチャを構築すると、お伝えしてきました。すでにビジネスの背景と購買の関係を整理するために、ドメイン駆動設計の境界付けられたコンテキストを利用してきました。

ここからはより実装に近い部分へ踏み込んでいきます。

さてアプリケーション全体の構成を考えたとき、ドメイン駆動設計単独では、どのように論理レイヤーを構成し、どの役割のオブジェクトをどのレイヤーに配置するのか規定されていません。そこで活用したいのがクリーンアーキテクチャです。

ドメイン駆動設計とクリーンアーキテクチャは非常に相性が良い設計手法です。

ドメイン駆動設計で大切なのはもちろんドメインになります。このとき、たとえば通常の垂直レイヤーアーキテクチャを用いて設計した場合、基本的に上から下への一方通行の依存関係になります。

![](/Article02/レイヤーモデル.PNG)

つまり、ドメインがインフラへのアクセス層に依存する形となってしまいます。

基本的に依存関係は、重要度の低い方から、高い方に向いていることが好ましいです。これは重要度が低い箇所の変更影響を、重要度の高い箇所が受けないようにするためです。このあたりの課題は[筆者のクリーンアーキテクチャの解説](https://www.nuits.jp/entry/easiest-clean-architecture-2019-09)を一読いただければ、ご理解いただけます。

ドメイン駆動設計においてドメインはもっとも大切な構成要素なので、リポジトリーの実装の影響をうけるようなことは避けるべきです。リポジトリーの実装がドメインに依存するように設計するべきです。これを実現するために手段としてクリーンアーキテクチャが利用できます。

下図は有名なクリーンアーキテクチャの図です。

![](/Article02/CleanArchitecture.jpg)

本稿では、垂直ではなくサークル状のレイヤーアーキテクチャを採用します。サークル状のレイヤーで大切なことは、依存関係は外側から内側への一方通行になっていて、逆は存在しないということです。中央のEntityをドメインと読み替えると、ほぼそのまま適用できるようになります。

ここであらためて、ドメイン・コンテキストビューの図を見なおしてみましょう。

![](/Article02/スライド10.PNG)

購買ドメインの上位にAdventureWorksドメインが存在します。AdventureWorksドメインは、認証・製造・販売ドメインからも利用される汎用的なドメインです。そのためEntityの部分を単純にドメインに置き換えるのではなく、AdventureWorksドメインと購買ドメインの2層に分けたほうが良さそうです。

またもっとも外側のFrameworks & Driverレイヤーの要素は、実際に今回のドメインで必要となるものに記載しましょう。

それらを反映した現在のレイヤーモデルはつぎのとおりです。

![](/Article02/スライド13.PNG)

外側が具象的で、内側がより抽象的な構造になっています。具体的な話の方が理解しやすいので、外側から順に説明していきましょう。

もっとも外側のFrameworks & Driverレイヤーは、アプリケーションで開発する対象外のレイヤーです。

ユーザーインターフェイスはWPF上に構築し、永続仮想としてはSQL Serverを利用します。また配置ビューからわかるよう、三層アーキテクチャとなるため、クライアントとデータベースをつなぐWeb APIをMagicOnionで実現します。

このFrameworks & Driverレイヤーの構成要素は抽象的に書かず、WPFやSQL Server、MagicOnionのように具体的な要素をプロットしましょう。

一番分かりやすいのはWPFでしょうか。WPFで実装する場合、とくに理由がなければMVVMパターンを採用するでしょう。MVVMパターンを前提に設計されたUIフレームワークだからです。

このようにUIフレームワークによって、その内側のプレゼンテーションの設計が限定されます。そのため設計に落としていくために最外周が決定した段階で具体的な名称を記載しておくと良いと思います。

とはいえ中心が抽象的で、外周に向かって具体化されているのは、中心が具象の影響を受けないようにするためです。これはつまり、具体的な決定をあと送りすることができることを表します。そのため無理に初期の段階で外側の具体名を埋める必要はありません。Interface Adapterの層を設計するまでに決定すれば十分です。

さてクリーンアーキテクチャはサークル状のレイヤーアーキテクチャです。

## レイヤーアーキテクチャにおける選択

レイヤーアーキテクチャには2つの選択肢があります。

1. 厳密なレイヤーアーキテクチャ
2. 柔軟なレイヤーアーキテクチャ

厳密なアーキテクチャを選択した場合は、直下への依存しか許可しません。柔軟なレイヤーアーキテクチャを選択した場合は、相対的に下位のレイヤーであれば依存（利用）を許可します。厳密なレイヤーアーキテクチャを採用した場合、レイヤーをまたいだ内側を利用したい場合、ひとつ外側がそれをラップして隠ぺいする必要があります。たとえば今回であれば、プレゼンテーションがドメインを利用する場合、つねにユースケースでラップして隠ぺいすることになります。

結論から言うと、今回は柔軟なレイヤーアーキテクチャを選択します。大きな理由が2つあります。

1. AdventureWorksドメインをラップしてしまうと、生産性や品質に対する影響が大きい
2. リポジトリーの実装などを考慮すると厳密なレイヤーアーキテクチャでは実現できない

### AdventureWorksドメインをラップしてしまうと、生産性や品質に対する影響が大きい

前述しましたが、AdventureWorksドメインにはつぎのようなオブジェクトを定義します。

|オブジェクト|説明|
|--|--|
|Date|時刻を持たない年月日|
|Days|日数|
|Dollar|通貨（日本企業の場合はYenなど）|
|Gram|重量グラム|
|DollarPerGram|グラム当たりの料金|

AdventureWorksドメインにおけるプリミティブな型をValue Objectとして実装するため、これらを一々ユースケースでラップすると生産性が低下しますし、ラップミスの発生もあり得るため、品質も低下します。

### リポジトリーの実装などを考慮すると厳密なレイヤーアーキテクチャでは実現できない

たとえば購買ドメインには購買先を表すVendorエンティティと、そのリポジトリーであるIVendorRepositoryインターフェイスを定義することになるでしょう。そして、VendorRepositoryクラスはゲートウェイに実装されます。

![](/Article02/スライド23.PNG)

VendorRepositoryクラスからIVendorRepositoryインターフェイスへの依存は、ユースケース層を跨いでいますが、さすがにここをユースケース層でラップするのは助長にすぎます。

というわけで今回は柔軟なレイヤーアーキテクチャを選択します。

初期の論理ビューとしては、いったんこの辺りとしておきましょう。