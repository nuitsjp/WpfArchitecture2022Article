# 非機能要件の実現

本章では非機能要件の中でも需要が高く、設計初期に共通で実施しておく必要のあるつぎの3つの非機能要件を例に、アーキテクチャを設計します。

1. 認証アーキテクチャ
2. 例外処理アーキテクチャ
3. ロギングアーキテクチャ

ログ出力をする場合、一般的に利用者情報を付加することが多いと思います。そのため、先に認証処理を実現するとむだが少ないため、さきに認証処理の設計を行う事とします。

# 認証アーキテクチャの注意点

**インターネットのように広く公開するサービスの場合は、適切な認証プロバイダーを選定してください。**

本稿では、実際に皆さんにコードを動かしていただくことを想定して、外部サービスを利用しないで実現する方式を選定しています。企業内ネットワークのような限定された環境では必要十分な設計だと思いますが、オープンに公開するためには認証機能を独自開発するようなリスクは避けるべきでしょう。また仮に企業内ネットワークであっても、ほかに利用できる認証プロバイダーがあるのであれば、そちらの利用をご検討ください。

たとえばAzure Active Directoryのような製品を利用することを検討してください。

# 認証アーキテクチャの設計

では認証アーキテクチャを設計していきましょう。それにあたり、いったん中心となるドメインを購買ドメインから認証ドメインに移します。

さて、詳細の前に注意点があります。

以下の図が購買ドメインを設計してきた、現時点の境界付けられたコンテキストです。

![](Article03/スライド1.PNG)

これはあくまで、購買ドメインを中心に見たモデルです。そのため、購買ドメインにとって重要度が低い部分は、意図的に省略してきました。

ここからしばらくは、認証の設計をしていくため、認証ドメインを中心に設計します。認証ドメインは、購買・製造・販売それぞれから「汎用」ドメインとして共有されるドメインとなります。そのため、個別のドメインの中で設計するよりは、認証ドメインを独立した設計書として設計していくのが良いかと思います。

## 認証ドメインからみた境界付けられたコンテキスト

さて、認証ドメインから境界付けられたコンテキストはつぎの通りです。

![](Article03/スライド2.PNG)

さすがに認証ドメイン視点とはいえ、認証ドメインがコアドメインになったりはせず、汎用ドメインのままでしょう。

ただしコアドメインは、購買ドメインではなく、販売ドメインとなるでしょう。営利企業なので販売が最優先だと判断しました。

また認証ドメインと他のドメインの関係に焦点を絞って設計しています。

認証ドメインは、購買・製造・販売ドメインから共有される汎用ドメインで、それらから依存されています。

また認証ドメインでは、たとえばログインユーザーなどの文脈は、AdventureWorksコンテキストの文脈を利用します。そのためAdventureWorksドメインに依存します。

認証処理では登録ユーザーを確認する必要があるでしょうから、汎用データベースドメインにも依存するでしょう。

このように視点が変わるとドメインの見え方は変わってきます。ドメインごとに境界付けられたコンテキストを定義することで、個々の境界付けられたコンテキストの複雑性を下げます。統合されたたった1つのモデルは、大きなドメインでは複雑すぎる場合があります。

また、すべての視点から正しい、たった1つのモデルを作るってメンテナンスし続けることは困難です。一定規模に分割して設計していくのが好ましいと考えています。

## 認証ドメインからみたコンテキストマップ

さて、これらをコンテキストマップとして記載したものが次の通りです。

![](Article03/スライド5.PNG)

認証とデータベースがいずれも汎用コンテキストなので、それらとの関係は、カスタマー・サプライヤーとし、AdventureWorksとは共有カーネルの関係とします。

## 認証の背景と要件

今回は、業務アプリケーションということで、つぎのような背景があるものとします。

1. 利用者はAdventure Works社の従業員である
2. 利用者はWindowsドメイン参加しているWindows OSから利用する
3. 利用者の勤務時間管理に、Windowsの起動・停止時間を利用している
4. 十分な休憩を挟んで勤務しているか、停止から起動のインターバルを参照して管理している

そのため、認証は非機能定義書において、つぎのような要件として定められているものとします。

1. Windows認証にてアカウントを特定する
2. 特定されたアカウントが従業員として登録されていれば利用可能とする
3. APIの呼出し時には、つど認証情報を検証する
4. 認証の有効期限は24時間とする
5. 期限を超えた場合、再認証する
6. 再認証はアプリケーションの再起動で行う

今回開発する対象は購買管理のシステムであり、日中の業務となり、日をまたいで継続した利用は通常運用では考えていません。また長時間認証された状態が維持されることはセキュリティ上好ましくありません。24時間は実用上長いですが、12時間では短く、その中間に適切な時間もないため24時間を有効期限とします。

## 認証方式の選択

gRPCで利用可能な認証方式は、次のようなものがあります。

1. Azure Active Directory
2. クライアント証明書
3. Identityサーバー
4. JSON Web Token
5. OAuth 2.0
6. OpenID Connect
7. WS-Federation

- [ASP.NET Core のための gRPC での認証と承認](https://learn.microsoft.com/ja-jp/aspnet/core/grpc/authn-and-authz?view=aspnetcore-7.0#other-authentication-mechanisms)

Windows認証が含まれていません。

実はgRPCでは直接Windows認証は利用できません。これは、gRPCがプラットフォームに依存しないHTTP/2プロトコルとTLSに基づいているためです。これにより、Windows認証のような特定のプラットフォームに依存する認証メカニズムはサポートされません。

ただこれは、gRPCで直接Windows認証が行えないというだけで、Windows認証の併用ができない訳ではありません。

すこし「メタ」な話になりますが、本稿では認証基盤は本質的な課題ではありません。また誰もがすぐに動かして試せる範囲に収めたいため、Azure Active DirectoryやIdentityサーバーなどは避けたいです。そこで今回はJSON Web Token（JWT）を活用して、Windows認証の認証情報をgRPCで利用します。

JWTを利用した認証方式は、オンプレのような閉じた環境でも利用しやすく、gRPCと組み合わせやすい特徴があります。Windows認証を適用したREST APIでJWTを作成し、gRPCで利用することで、gRPCでもWindows認証で認証されたトークンを利用できます。

JSON Web Token（JWT）は、デジタル署名されたJSONデータ構造で、認証と認可情報を交換するために使用されます。JWTは3つのパートで構成されており、それぞれBase64Urlエンコードされた形式で、ドット（.）で区切られています。これらのパートは、ヘッダー、ペイロード、署名です。

```txt
例：
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

|パート|説明|
|--|--|
|ヘッダー（Header）|トークンのタイプと使用する署名アルゴリズムを指定します。<br>例: {"alg": "HS256", "typ": "JWT"}|
|ペイロード（Payload）|クレームと呼ばれる情報（ユーザーID、有効期限など）を含むJSONデータです。<br>例: {"sub": "1234567890", "name": "John Doe", "iat": 1516239022}|
|署名（Signature）|ヘッダーとペイロードを結合し、秘密鍵を使ってデジタル署名を生成します。これにより、トークンの内容が改ざんされていないことが検証できます。|

JWTを使用すると、クライアントとサーバー間で認証情報を安全かつ効率的に交換できます。ただし、機密データは含めないように注意してください。

## 認証処理の概略

さてJWTはトークンの仕様であり、認証されたトークンが有効なものかどうかを検証する仕組みしか実はありません。どのようにWindows認証を行い、どうトークンを作成するかまでは含まれていません。

トークンはサーバーサイドで、秘密鍵を用いて何らかの方法で発行する必要があります。

ノード・コンポーネント・鍵の配置は、つぎのようになるでしょう。

![](Article03/スライド3.PNG)

そのうえで、つぎのように振舞います。

![](Article03/スライド4.PNG)

購買アプリケーションは、起動時にRESTの認証APIを呼び出します。認証APIはRESTなので、Windows認証して呼び出し元の利用者のユーザーIDを取得できます。

取得したユーザーIDを認証データベースと照らし合わせて、利用者情報を取得します。

データベースにユーザーが無事登録されていたら、利用者情報からトークンを作成して秘密鍵で署名して、トークンを購買アプリに返却します。

購買アプリは、署名されたトークンをHTTPヘッダーに付与して購買APIを呼び出します。購買APIでは、トークンを公開鍵で複合して検証し、問題なければAPIの利用を許可します。

トークンには発行日時を含められるため、利用期限を設けることができますし、任意の情報を付与できるため、購買APIを利用するために必要なユーザー情報（たとえば従業員IDなど）をトークンに含めておくこともできます。都度ユーザー情報を取得するようなオーバーヘッドを避けられます。

また購買API上だけでなく、購買アプリ上でも公開鍵を用いて復号することで、トークンに含まれた情報を利用できます。

あたり前ですが、非常に良くできた仕組みですね。

## 認証ドメインの論理ビュー設計

さて、これらの検討結果から、論理ビューを設計してみましょう。そこんな感じでしょうか？

![](Article03/スライド6.PNG)

UserSerializerがレイアウトの都合上、右上の左下の2カ所に配置していますがご了承ください。

まず最外周にUIがありません。認証ドメインは、他のドメインに認証機能を提供するドメインのため、UIが存在しないからです。

その代わりにWindows認証を行うためのWeb API（REST）があります。

またユースケースレイヤーもありません。認証ドメインにも「ユースケース（利用シーンの意味）」はあります。認証と検証ですね。ただ、ユースケース単位のオブジェクトは必要ないと考えたので、ユースケースレイヤーは利用しません。

こんな感じで、外周やレイヤーなど、必要に応じて取捨選択したり、必要なものを追加します。クリーンアーキテクチャの「例の図」にあるレイヤー構成や構成要素に限定して考える必要はまったくありません。

さて登場オブジェクトを見てみましょう。

|レイヤー|オブジェクト|説明|
|--|--|--|
|AdventureWorksドメイン|User|システムの利用者|
||IUserRepository|Userのリポジトリー|
|認証ドメイン|IAuthenticationService|認証処理を実施し、IAuthenticationContextを初期化する|
||IAuthenticationContext|認証されたユーザーを扱う、認証コンテキスト|
|コントローラー・ゲートウェイ|UserSerializer|UserとJWTのシリアライズ・デシリアライズを行う|
||AuthenticationServiceClient|REST APIを呼び出して認証処理を行う|
||AuthenticationController|REST APIを提供し、Windows認証からユーザーを特定して利用者を認証する|
||ClientAuthenticationContext|IAuthenticationContextを実装した、gRPC用の認証コンテキスト。IAuthenticationContextと異なり、JWTトークンを保持して、gRPCを呼び出す際にサーバーサイドにトークンを渡す。|
||AuthenticationFilter|gRPCのクライアントを呼び出すと、必ず通過するフィルター。ClientAuthenticationContextからトークンを取得してヘッダーに付与することで認証情報をサーバーサイドに渡す。|
||ServerAuthenticationContext|IAuthenticationContextのgRPCサーバーサイド実装。クライアント側は1プロセス1ユーザーだが、サーバーサイドは1プロセスマルチユーザーのため、異なる実装が必要となる。|
||AuthenticationFilterAttribute|gRPCのサーバーサイドが呼び出された場合に必ず通過するフィルター。リクエストヘッダーからトークンを取得し、UserSerializerで複合することでユーザーの検証を行う。|

さきにも少し触れましたが、認証ドメインではざっくり言うと、認証と検証の2種類のユースケースがあります。認証はRESTで、検証はgRPCの利用時に行います。

そのため、上図のオブジェクトはつぎの2つのユースケースで考えると分かりやすいです。

1. REST APIによるユーザーの認証処理
2. gRPC利用時のユーザーの検証処理

RESTで認証された際に作られたJWTを利用して、gRPCを呼出し、正しく認証されたユーザーにだけgRPC APIの利用を許可します。順番に見ていきましょう。

### REST APIによる認証処理

RESTによる認証は、WPFアプリケーションの起動時に実施します。だいたいつぎのような流れになります。検証処理側は除外しています。

![](Article03/スライド7.PNG)

アプリケーションの起動時に、最初の画面のロードイベントで認証サービスを呼び出します。

認証は最初のスプラッシュ画面やローディング画面を表示した後に実施します。画面表示前に実施しておいて、認証情報をDIコンテナーに登録してしまうのがもっとも簡単です。ただその場合、初期画面の表示に時間が掛かってしまいます。そのため、初期画面を表示しておいて、初期画面で認証処理を行います。

ほかにはアプリケーション本体の画面とは別に、何らかの方法でスプラッシュを表示しておいて、認証し、認証情報をDIコンテナーに登録する方法もありだと思います。ただ今回は、初期画面で処理するようにしています。

では実際ながれを追っていきましょう。

①初期画面の遷移時にIAuthenticationServiceを呼び出します。

IAuthenticationServiceの実体はAuthenticationServiceで、HttpClientを利用して、②サーバーサイドの認証サービスを呼び出します。ここのAPIは前述のとおりRESTです。

サーバーサイドではAuthenticationControllerがリクエストを受け取り、③Windows認証を使ってアカウントを特定し、④IUserRepositoryを利用して、アカウントに対応する適切なUserか判定します。

![](Article03/スライド8.PNG)

適切なユーザーであれば、⑤UserSerializerを利用して認証されたUserをJSON Web Token（JWT）にシリアライズします。この時秘密鍵で署名することで、公開鍵でトークンが正しいものであることを検証できるようにします。JWTはレスポンスとして返却します。

AuthenticationServiceではレスポンスからトークンを受け取り、⑥トークンを復元してユーザー情報をClientAuthenticationContextへ設定します。

### gRPC利用時のユーザーの検証処理

さて、続いてはアプリケーション操作時にgRPCを呼び出した際の検証処理です。

![](Article03/スライド9.PNG)

①ユーザーが購買アプリケーションで何らかの操作をすると、ViewModelはgRPCのクライアント経由でサーバーサイドを呼び出します。

この時、gRPCクライアントにAuthenticationFilterを適用して②JWTトークンをHTTPヘッダーに付与します。

gRPCのサーバーサイドでは、AuthenticationFilterAttributeが受け取ったリクエストのヘッダーのauthorizationからJWTを取得します。取得したトークンを③UserSerializer.Deserializeをつかって複合します。

ただしく複合できたら、④ServerAuthenticationContextに設定することで、以後必要に応じて利用します。

概ね悪くなさそうですね。では実際にコードを書きつつ、実装ビューを作って詳細に設計を落としていきましょう。