# アーキテクチャ設計の構成

過去に記載した「[実践WPF業務アプリケーションのアーキテクチャ【概要編】 ～ マイクロソフト公式サンプルデータベースAdventureWorksを題材に](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwijj-XDpvD9AhVtS2wGHVCWACcQFnoECB4QAQ&url=https%3A%2F%2Fcodezine.jp%2Farticle%2Fdetail%2F10727&usg=AOvVaw0nFMOXzm1dpqOjvMuyfoHA)」では、アーキテクチャをRational Unified Process（RUP）にて提唱された4＋1ビューを用いて記載・説明しました。

![](/Article02/スライド20.PNG)

ただ4+1ビューではつぎのような点で設計が導きにくいと感じてきました。

- ドメイン駆動設計との統合
- 非機能要件
- データの永続化手段と利用方法
- バージョン管理やCI/CD

これらを踏まえると、つぎのような視点（ビュー）でアーキテクチャを表現するのが良いと考えています。

|No.|ビュー|説明|おもなモデル|
|--|--|--|--|
|1|ドメインビュー|境界付けられたコンテキストとコンテキストマップを用いてドメインとコンテキストを設計する。|境界付けられたコンテキスト、コンテキストマップ|
|2|ユースケースビュー|アーキテクチャを決定するための代表的なユースケースを選択・設計する。|クラス図、シーケンス図|
|3|非機能要件ビュー|アーキテクチャに影響を与える非機能要件を特定・設計する。|クラス図、シーケンス図|
|4|論理ビュー|ソフトウェアの論理レイヤー構成を設計する。レイヤー内の代表的なオブジェクトを抽出し、依存関係を設計する。|パッケージ図、クラス図|
|5|実装ビュー|論理ビューで抽出された代表的なオブジェクトをコンポーネントに分割配置する。|コンポーネント図|
|6|配置ビュー|システム全体の論理ノード構成と、ノード上へのコンポーネントの配置を設計する。|配置図|
|7|データビュー|システムが扱うデータの永続化方法、利用方法を設計する。|ER図、クラス図、シーケンス図|
|8|プロセスビュー|並行性やパフォーマンス要件で特別な検討が必要と考えられるアーキテクチャを設計する。|アクティビティ図、シーケンス図|
|9|開発者ビュー|システムの開発プロセスやツールを設計する。バージョン管理、CI、自動テストなどを含む。|配置図、シーケンス図|

## ドメインビュー

アーキテクチャ設計書のドメインビューでは、境界付けられたコンテキストとコンテキストマップを用いてドメインとコンテキストを設計します。

予算編で仮の境界付けられたコンテキストを作成しましたが、まずは対応するコンテキストマップを作成します。コンテキストマップではコンテキスト間の関係の種類を明確にします。関係の種類には共有カーネルやカスタマー・サプライヤー、腐敗防止層などが含まれます。

関係の種類を考慮して、論理ビュー・実装ビュー・配置ビューを設計します。

## ユースケースビュー

4+1ビューが提唱されたRUPにおけるユースケースビューには、すべてのユースケースやアクターの抽出を含む、ユースケースモデルの完成ととれる意図が含まれていたと思います。

ただそこまでいくと実質的な要件定義となってしまいます。それがダメという訳ではないのですが、アーキテクチャ設計の一部として記載することに個人的には違和感があります。

これは要件定義のリーダーと、アーキテクチャ設計のリーダーが異なりことも多く、プロセスとしても要件定義とアーキテクチャ設計は部分的にオーバーラップして実施されることも多いからです。

要件は要件で文書化し、その要件を満たすアーキテクチャを設計するという流れが個人的にはしっくりきます。まず利用者に提供すべき価値（機能・ユースケース）があり、それの手段としてアーキテクチャがあるはずです。そのためドキュメント体系としては、アーキテクチャ設計書の前にユースケース定義書（要件定義書）があるべきだと考えています。

ただアーキテクチャ設計書のユースケースビューには、ユースケースの実現を設計する役割もあります。

そこでユースケース定義書（要件定義書）によって設計されたユースケースを実現する上で、アーキテクチャ的なパターンを絞り込み、パターン別の実現方法を設計する役割をユースケースビューに残すこととしました。

## 非機能要件ビュー

従来の4+1ビューでは、機能要件に対する実現は明確に記載されていましたが、非機能要件の実現が考慮しきれていませんでした。

そこで、機能要件に対するユースケースビューと同様に、非機能要件に対する非機能要件ビューを追加しました。

非機能全体の定義は、ユースケースビューと同様に、非機能要件定義書のような文書で定義されている前提条件とします。

非機能要件には、たとえば保守・運用に関する要件なども含まれます。そのため非機能要件ビューでは、定義ずみの非機能要件からアーキテクチャ上考慮が必要な要件を特定し、その実現方法を設計します。

## 論理ビュー

システムを実現するための代表的なオブジェクトを抽出し、それらを配置する論理的なレイヤー構成を決定します。

他のビューでも同様ですが、論理ビューに記載する内容は、論理ビュー内の設計ですべて完成させることはできません。とくにユースケースや非機能要件の実現を設計する中で新しいオブジェクトが登場してきます。そのため複数のビューを行ったり来たりしながら設計を進めていくことになります。

## 実装ビュー

論理ビューで抽出されたオブジェクトを、どのようにコンポーネントに分割配置するか設計します。

つまりVisual Studio上のプロジェクト（.csproj）をどのように分割して、どのクラスをどのプロジェクトに配置するのか決定します。

.NETの場合、プロジェクトの分割によって厳密な依存関係を規定できるため非常に重要です。安易にプロジェクトを統合してしまうと、すぐに好ましくない依存関係を実装してしまいがちだからです。

ViewとViewModelで考えると非常に分かりやすいでしょう。

MVVMパターンで設計する場合、ViewはViewModelに依存しますが、その逆をしてしまうと循環参照になってしまいます。しかし細かな実装をしていると、ついついViewModelからViewを操作してしまいたくなります。それで正しく動作することもありますが、WPFの場合はListなどが仮想化されている関係上、Viewを直接操作してしまうと不具合のもとになることもあります。また単純に依存関係が双方向になると、コードが追いきれないきれいスパゲッティなコードになって、後日のメンテナンスで苦労しがちです。

そのため依存関係を適切に制御するため、プロジェクトをどう分割するかは、非常に重要な設計になります。

## 配置ビュー

どのノードに、どのコンポーネントを配置するか設計します。

このとき実装ビューで抽出したコンポーネントだけでなく、サードパーティのライブラリーやランタイム・OS・ミドルウェアなども記載します。

ノードは論理的なノードとして扱い、物理的なノード設計はアーキテクチャ設計とは別に設計します。物理的な設計はインフラの詳細な設計にフォーカスするためです。

## データビュー

システムが扱うデータの永続化方法、利用方法を設計します。

- 永続化先はファイルシステムなのか？RDBなのか？NoSQLなのか？
- RDBだとしたらスキーマをどのように設計するのか？接続時のユーザーはどのように割り当てるのか？
- RDBをどのように利用するのか？Entity Frameworkか？Dapperか？

そういった内容を設計します。

データベース全体のER図のような、詳細な設計は含めず、別途データベースの詳細設計書などに記載します。

## プロセスビュー

並行性やパフォーマンス要件で特別な検討が必要と考えられるアーキテクチャを設計します。

ほとんどの場合は、.NET（async/awaitなど）やASP.NET Coreなどがになってくれるため、それらを単純に使うだけなら特別な設計は不要です。

今回のケースではWPFのプロセスを起動する際のDependency Injection（DI）コンテナーの初期化に関連する設計が必要になります。

## 開発者ビュー

システムの開発プロセスやツールを設計します。

- IDEには何を使うのか？
- ユーザーの開発環境に必要なランタイムやミドルウェアはなにか？
- バージョン管理には何を使うか？
- Gitを使うとした場合、そのブランチ戦略は？
- Unit Testフレームワークには何を使うか？
- CIはどのように行うか？
- CI時の自動テストは？

そういった日々の開発者体験に直結するプロセスやツールを決定します。ある意味では開発者にとって一番大切な部分でもあります。

# 設計編の構成

前述の構成は、アーキテクチャ設計書としては読みやすいと思います。

しかし実際にアーキテクチャ設計を行っていく場合、各ビューを頻繁に行ったり来たりしながら記述します。いずれかを先に完璧に書きあげるという訳には行きません。

たとえば論理ビューから実装ビュー・配置ビューは概ねその方向に流れて設計しますが、論理ビュー自体がユースケースビューや非機能要件ビューの設計に伴い頻繁に更新されるため、ウォーターフォール的な流れにはならず、インクリメンタルなプロセスになります。

本稿では「アーキテクチャ設計書はこうなります」という設計結果をお見せするのではなく、どのようにアーキテクチャを設計していくか解説したいと考えています。そのため設計書としてのアーキテクチャ設計とは、やや異なったアプローチで記載します。

そこで設計編では、つぎの構成で記載していきたいと思います。

1. 前編
   1. 初期ドメインビューの設計
   2. 初期ユースケースビューの設計
   3. 初期非機能要件ビューの設計
   4. 初期配置ビューの設計
   5. 初期論理ビューの設計
   6. 初期実装ビューの設計
   7. データビューの設計
   8. プロセスビューの設計
2. 後編
   1. 非機能要件の実現
   2. 代表的なユースケースの実現
   3. 開発者ビューの設計

## 前編

本稿、前編ではまずはざっくりしたアーキテクチャの概略を設計します。

この段階ではあまり正確なものを作ることに拘る必要はありません。正確なアーキテクチャはすべてのユースケースや非機能要件が実現されるまで完成しません。

そのため、まずは後編に記載があるような代表的なユースケースの実現に着手できる状態とします。速度を優先し、正確性はある程度目をつぶりましょう。

これはいい加減で良いという意味ではありません。とくに類似のアーキテクチャに対する経験が多い方は、この段階でかなり正確な設計が可能です。ただ、悩んで何日も手が止まってしまうくらいなら、先に進めてからフィードバックすれば良いと思います。

## 後編

後編では非機能やユースケースの実現を設計します。

ユースケースの設計をしていく場合、机上ですべて設計するのは難しくて、仮実装しながら設計していくことも多いと思います。その場合に、認証やロギングの機能が実装されていないと、そもそもユースケースを実装できなかったり、エラーの解析が困難になったりします。そこで非機能のうち重要な部分を、ユースケースより先に設計します。

非機能要件は、アーキテクチャに影響があるすべての非機能要件について設計する必要があります。ただ紙面の都合もありますので、今回は普遍的に活用できそうないくつかの非機能に絞って設計したいと思います。

ユースケースの実現は、必ずしもすべてのユースケースを同じ粒度でアーキテクチャ設計書に記載する必要はありません。ユースケースをアーキテクチャ的な視点でパターン分けして、同一パターンの中から代表的なユースケースを選定します。その代表的なユースケースに絞って記載する形とします。

これらの中で、各ビューにフィードバックしていき、アーキテクチャ全体の精度を上げていきます。

そして最後に開発者ビューを設計します。本稿の構成上最後に記載しますが、実際には最後に書かないといけないという訳ではありません。書けるタイミングで順次記載していき、開発上必要になるタイミングまでに完成させれば良いかと思います。

では！いってみましょう！

